<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Reactive Certificate-Based Client Authentication in HTTP/2</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1000px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 700px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a:link, h2 a:link, h3 a:link, h4 a:link {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
table > thead > th {
  border-bottom: 2px solid #ddd;
}
table > tbody > tr > td, table > tbody > tr > th {
  border-top: 1px solid #ddd;
}
table > tbody > tr:nth-child(2n+1) > td,
table > tbody > tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.right {
  text-align: right;
}
td.reference {
  max-width: 200px;
}
td.right, td.left, td.reference, td.top {
  border-top: none;
}


table.header {
  width: 100%;
}
table.header > tbody > tr > td {
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract +p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
}

pre.text, pre.text2 {
  width: 90%;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
td.reference {
  padding-right: 1em;
  vertical-align: top;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a:link {
  color: #2a6496;
}
a:link:hover {
  background-color: #eee;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Reactive Certificate Authentication in HTTP/1.1"/>
<link href="#rfc.section.1.1.1" rel="Chapter" title="1.1.1 Using TLS 1.2 and previous"/>
<link href="#rfc.section.1.1.2" rel="Chapter" title="1.1.2 Using TLS 1.3"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Reactive Client Authentication in HTTP/2"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Presenting Client Certificates at the HTTP/2 Framing Layer"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 The CERTIFICATE_REQUEST Frame"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 The CERTIFICATE_REQUIRED frame"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 The CERTIFICATE frame"/>
<link href="#rfc.section.2.3.1" rel="Chapter" title="2.3.1 The Certificate structure"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 The CERTIFICATE_PROOF Frame"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 The USE_CERTIFICATE Frame"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Indicating failures during HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Indicating Support for HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 New HTTP/2 Frames"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 CERTIFICATE_REQUIRED"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 CERTIFICATE_REQUEST"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 CERTIFICATE"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 CERTIFICATE_PROOF"/>
<link href="#rfc.section.6.2.5" rel="Chapter" title="6.2.5 USE_CERTIFICATE"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 New HTTP/2 Error Codes"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 BAD_CERTIFICATE"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 UNSUPPORTED_CERTIFICATE"/>
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 CERTIFICATE_REVOKED"/>
<link href="#rfc.section.6.3.4" rel="Chapter" title="6.3.4 CERTIFICATE_EXPIRED"/>
<link href="#rfc.section.6.3.5" rel="Chapter" title="6.3.5 BAD_SIGNATURE"/>
<link href="#rfc.section.6.3.6" rel="Chapter" title="6.3.6 CERTIFICATE_GENERAL"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M. and M. Bishop" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-http2-client-certs-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-12-23" />
  <meta name="dct.abstract" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2." />
  <meta name="description" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">HTTP</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Expires: June 25, 2016</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">December 23, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Reactive Certificate-Based Client Authentication in HTTP/2<br />
  <span class="filename">draft-thomson-http2-client-certs-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2.</p>
<p>This document describes a how client authentication might be requested by a server as a result of receiving a request to a protected resource.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 25, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Reactive Certificate Authentication in HTTP/1.1</a></li>
<ul><li>1.1.1.   <a href="#rfc.section.1.1.1">Using TLS 1.2 and previous</a></li>
<li>1.1.2.   <a href="#rfc.section.1.1.2">Using TLS 1.3</a></li>
</ul><li>1.2.   <a href="#rfc.section.1.2">Reactive Client Authentication in HTTP/2</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Presenting Client Certificates at the HTTP/2 Framing Layer</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">The CERTIFICATE_REQUEST Frame</a></li>
<li>2.2.   <a href="#rfc.section.2.2">The CERTIFICATE_REQUIRED frame</a></li>
<li>2.3.   <a href="#rfc.section.2.3">The CERTIFICATE frame</a></li>
<ul><li>2.3.1.   <a href="#rfc.section.2.3.1">The Certificate structure</a></li>
</ul><li>2.4.   <a href="#rfc.section.2.4">The CERTIFICATE_PROOF Frame</a></li>
<li>2.5.   <a href="#rfc.section.2.5">The USE_CERTIFICATE Frame</a></li>
</ul><li>3.   <a href="#rfc.section.3">Indicating failures during HTTP-Layer Certificate Authentication</a></li>
<li>4.   <a href="#rfc.section.4">Indicating Support for HTTP-Layer Certificate Authentication</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></li>
<li>6.2.   <a href="#rfc.section.6.2">New HTTP/2 Frames</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">CERTIFICATE_REQUIRED</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">CERTIFICATE_REQUEST</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">CERTIFICATE</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">CERTIFICATE_PROOF</a></li>
<li>6.2.5.   <a href="#rfc.section.6.2.5">USE_CERTIFICATE</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">New HTTP/2 Error Codes</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">BAD_CERTIFICATE</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">UNSUPPORTED_CERTIFICATE</a></li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">CERTIFICATE_REVOKED</a></li>
<li>6.3.4.   <a href="#rfc.section.6.3.4">CERTIFICATE_EXPIRED</a></li>
<li>6.3.5.   <a href="#rfc.section.6.3.5">BAD_SIGNATURE</a></li>
<li>6.3.6.   <a href="#rfc.section.6.3.6">CERTIFICATE_GENERAL</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Many existing HTTP <a href="#RFC7230">[RFC7230]</a> servers have different authentication requirements for the different resources they serve.  Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS <a href="#I-D.ietf-tls-tls13">RFC5246</a> <cite title="NONE">[I-D.ietf-tls-tls13]</cite> layer.</p>
<p id="rfc.section.1.p.2">For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake.  However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate.  Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p>
<p id="rfc.section.1.p.3">The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer.  Servers that rely on certificate-based authentication might request different certificates for different resources.  Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p>
<p id="rfc.section.1.p.4">Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources.  Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p>
<p id="rfc.section.1.p.5">In Yokohama, there was extensive working group discussion regarding why certificate authentication could not easily be done at the HTTP semantic layer.  However, in subsequent discussion, it became apparent that the HTTP <em>framing</em> layer did not suffer from the same limitation.</p>
<p id="rfc.section.1.p.6">In this document, a mechanism for doing certificate-based client authentication via HTTP/2 frames is defined.  This mechanism can be implemented at the HTTP layer without requiring new TLS stack behavior and without breaking the existing interface between HTTP and applications which employ client certificates.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#reactive-certificate-authentication-in-http11" id="reactive-certificate-authentication-in-http11">Reactive Certificate Authentication in HTTP/1.1</a></h1>
<h1 id="rfc.section.1.1.1"><a href="#rfc.section.1.1.1">1.1.1.</a> <a href="#using-tls-12-and-previous" id="using-tls-12-and-previous">Using TLS 1.2 and previous</a></h1>
<p id="rfc.section.1.1.1.p.1">In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established.  Instead, it only requests a client certificate when a request is made to a resource that requires a certificate.  TLS 1.2 <a href="#RFC5246">[RFC5246]</a> accomodates this by permitting the server to request a new TLS handshake, in which the server will request the client&#8217;s certificate.</p>
<p><a href="#ex-http11">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p>
<div id="rfc.figure.1"/>
<div id="ex-http11"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre>
<p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p>
<p id="rfc.section.1.1.1.p.3">In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure 1</a>).  Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p>
<p id="rfc.section.1.1.1.p.4">The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2).  The client then initiates a TLS handshake.  Note that some TLS messages are elided from the exchange for the sake of brevity.</p>
<p id="rfc.section.1.1.1.p.5">The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource.  The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p>
<p id="rfc.section.1.1.1.p.6">When the handshake completes, the server performs any authorization checks a second time.  With the client certificate available, it then authorizes the request and provides a response (*5).</p>
<h1 id="rfc.section.1.1.2"><a href="#rfc.section.1.1.2">1.1.2.</a> <a href="#using-tls-13" id="using-tls-13">Using TLS 1.3</a></h1>
<p id="rfc.section.1.1.2.p.1">TLS 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed.  For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation.  <a href="#ex-tls13">Figure 2</a> shows the simpler exchange this enables.</p>
<div id="rfc.figure.2"/>
<div id="ex-tls13"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate -----------------------&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre>
<p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p>
<p id="rfc.section.1.1.2.p.2">TLS 1.3 does not support renegotiation, instead supporting direct client authentication.  In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#reactive-client-authentication-in-http2" id="reactive-client-authentication-in-http2">Reactive Client Authentication in HTTP/2</a></h1>
<p id="rfc.section.1.2.p.1">An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation.  The client is able to assume that the next unanswered request on the connection is responsible.  The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request.  This ensures that the application has the right contextual information for processing the request.</p>
<p id="rfc.section.1.2.p.2">In HTTP/2, a client can have multiple outstanding requests.  Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p>
<p id="rfc.section.1.2.p.3">Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with either a TLS renegotiation or CertificateRequest.</p>
<p id="rfc.section.1.2.p.4">Such an identifier could be added to TLS 1.2 by means of an extension, but many TLS 1.2 implementations do not permit application data to continue during a renegotiation.  This is problematic for a multiplexed protocol like HTTP/2.  Instead, this draft proposes bringing the TLS 1.3 CertificateRequest and Certificate messages into HTTP/2 frames, making client certificate authentication TLS-version-agnostic.</p>
<div id="rfc.figure.3"/>
<div id="ex-http2"/>
<pre>
Client                                      Server
   -- (streams 1,3,5) GET /protected ----------&gt;
   &lt;---- (streams 1,3,5) CERTIFICATE_REQUIRED --
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream 0) CERTIFICATE_PROOF ------------&gt;
   ------ (stream 1,3,5) USE_CERTIFICATE* -----&gt;
   &lt;------------------ (streams 1,3,5) 200 OK --
   
* - Optional
</pre>
<p class="figure">Figure 3: HTTP/2 Reactive Certificate Authentication</p>
<p><a href="#certs-http2">Section 2</a> describes how certificates can be requested and presented at the HTTP/2 framing layer using several new frame types which parallel the TLS 1.3 message exchange.  <a href="#errors">Section 3</a> defines new error types which can be used to notify peers when the exchange has not been successful.  Finally, <a href="#setting">Section 4</a> describes how an HTTP/2 client can announce support for this feature so that a server might use these capabilities.</p>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.1.3.p.1">RFC 2119 <a href="#RFC2119">[RFC2119]</a> defines the terms &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221; and &#8220;MAY&#8221;.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#certs-http2" id="certs-http2">Presenting Client Certificates at the HTTP/2 Framing Layer</a></h1>
<p id="rfc.section.2.p.1">An HTTP/2 request from a client that has signaled support for reactive certificate authentication (see <a href="#setting">Section 4</a>) might cause a server to request client authentication.  In HTTP/2 a server does this by sending at least one <samp>CERTIFICATE_REQUEST</samp> frame (see <a href="#http-cert-request">Section 2.1</a>) on stream zero.</p>
<p id="rfc.section.2.p.2">The server SHOULD first send a <samp>CERTIFICATE_REQUIRED</samp> frame (see <a href="#http-cert-required">Section 2.2</a>) on the stream which triggered the request for client credentials. The Request-ID field of the <samp>CERTIFICATE_REQUEST</samp> frame is populated by the server with the same value in the <samp>CERTIFICATE_REQUIRED</samp> frame. Subsequent <samp>CERTIFICATE_REQUIRED</samp> frames with the same request identifier MAY be sent on other streams where the server is expecting client authentication with the same parameters. This allows a client to correlate the <samp>CERTIFICATE_REQUEST</samp> with one or more outstanding HTTP requests.</p>
<p id="rfc.section.2.p.3">A server MAY send multiple concurrent <samp>CERTIFICATE_REQUEST</samp> frames. If a server requires that a client provide multiple certificates before authorizing a single request, it MUST send a <samp>CERTIFICATE_REQUIRED</samp> frame with a different request identifier and a corresponding <samp>CERTIFICATE_REQUEST</samp> frame for each required certificate.</p>
<p id="rfc.section.2.p.4">Clients provide certificate authentication by sending one or more <samp>CERTIFICATE</samp> frames (see <a href="#http-certificate">Section 2.3</a>) on stream zero, followed by a <samp>CERTIFICATE_PROOF</samp> frame. If the <samp>CERTIFICATE_PROOF</samp> frame is marked as both <samp>SOLICITED</samp> and <samp>AUTOMATIC_USE</samp>, the provided certificate can be immediately applied by the server to all streams on which a <samp>CERTIFICATE_REQUIRED</samp> frame has been sent previously with the same identifier. Otherwise, the client will send subsequent <samp>USE_CERTIFICATE</samp> frames (see <a href="#http-use-certificate">Section 2.5</a>) to indicate the streams on which it intends the certificate to be considered.</p>
<p id="rfc.section.2.p.5">Clients may also provide authentication without being asked, if desired, by sending <samp>CERTIFICATE</samp>, <samp>CERTIFICATE_PROOF</samp>, and <samp>USE_CERTIFICATE</samp> frames without waiting for a server-generated <samp>CERTIFICATE_REQUEST</samp>. If a client receives a <samp>CERTIFICATE_REQUIRED</samp> frame referencing parameters for which it has already provided a matching certificate, it MAY reply with a <samp>USE_CERTIFICATE</samp> frame referencing the previous <samp>CERTIFICATE</samp> frame.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#http-cert-request" id="http-cert-request">The CERTIFICATE_REQUEST Frame</a></h1>
<p id="rfc.section.2.1.p.1">TLS 1.3 defines the <samp>CertificateRequest</samp> message, which prompts the client to provide a certificate which conforms to certain properties specified by the server.  This draft defines the <samp>CERTIFICATE_REQUEST</samp> frame (0xFRAME-TBD1), which contains the same contents as a TLS 1.3 <samp>CertificateRequest</samp> message, but can be sent over any TLS version.</p>
<p id="rfc.section.2.1.p.2">The <samp>CERTIFICATE_REQUEST</samp> frame MUST NOT be sent by clients.  A <samp>CERTIFICATE_REQUEST</samp> frame received by a server SHOULD be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.2.1.p.3">The <samp>CERTIFICATE_REQUEST</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE_REQUEST</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.4"/>
<div id="fig-cert-request"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | ID-Length (8) |               Request-ID                    ...
 +-------------------------------+-------------------------------+
 |     Algorithm-Count (16)      |          Algorithms         ...
 +---------------------------------------------------------------+
 |       CA-Count (16)           |  Certificate-Authorities(?) ...
 +---------------------------------------------------------------+
 | Cert-Extension-Count (16)     |       Cert-Extensions(?)    ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 4: CERTIFICATE_REQUEST frame payload</p>
<p id="rfc.section.2.1.p.4">The frame contains the following fields:</p>
<p/>

<dl>
  <dt>ID-Length and Request-ID:</dt>
  <dd style="margin-left: 8"><samp>Request-ID</samp> is a variable-length opaque identifier used to correlate subsequent certificate-related frames with this request.  The identifier MUST be the output of a cryptographically-secure pseudo-random function.  The size of the <samp>Request-ID</samp> field is given by the 8-bit <samp>ID-Length</samp> field, which MUST NOT be zero.</dd>
  <dt>Algorithm-Count and Algorithms:</dt>
  <dd style="margin-left: 8">A list of the hash/signature algorithm pairs that the server is able to verify, listed in descending order of preference. Any certificates provided by the client MUST be signed using a hash/signature algorithm pair found in <samp>Algorithms</samp>. Each algorithm pair is encoded as a <samp>SignatureAndHashAlgorithm</samp> (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), and the number of such structures is given by the 16-bit <samp>Algorithm-Count</samp> field, which MUST NOT be zero.</dd>
  <dt>CA-Count and Certificate-Authorities:</dt>
  <dd style="margin-left: 8"><samp>Certificate-Authorities</samp> is a series of distinguished names of acceptable certificate authorities, represented in DER-encoded <a href="#X690">[X690]</a> format.  These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space. The number of such structures is given by the 16-bit <samp>CA-Count</samp> field, which MAY be zero. If the <samp>CA-Count</samp> field is zero, then the client MAY send any certificate that meets the rest of the selection criteria in the <samp>CERTIFICATE_REQUEST</samp>, unless there is some external arrangement to the contrary.</dd>
  <dt>Cert-Extension-Count and Cert-Extensions:</dt>
  <dd style="margin-left: 8">A list of certificate extension OIDs <a href="#RFC5280">[RFC5280]</a> with their allowed values, represented in a series of <samp>CertificateExtension</samp> structures (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.5). The list of OIDs MUST be used in certificate selection as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>. The number of Cert-Extension structures is given by the 16-bit <samp>Cert-Extension-Count</samp> field, which MAY be zero.</dd>
</dl>
<p id="rfc.section.2.1.p.6">Some certificate extension OIDs allow multiple values (e.g. Extended Key Usage). If the sender has included a non-empty certificate_extensions list, the certificate MUST contain all of the specified extension OIDs that the recipient recognizes. For each extension OID recognized by the recipient, all of the specified values MUST be present in the certificate (but the certificate MAY have other values as well).  However, the recipient MUST ignore and skip any unrecognized certificate extension OIDs.</p>
<p id="rfc.section.2.1.p.7">PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that implementations will rely on their PKI libraries to perform certificate selection using these certificate extension OIDs.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#http-cert-required" id="http-cert-required">The CERTIFICATE_REQUIRED frame</a></h1>
<p id="rfc.section.2.2.p.1">The <samp>CERTIFICATE_REQUIRED</samp> frame (0xFRAME-TBD2) is sent by servers to indicate that processing of a request is blocked pending certificate authentication. The frame includes a request identifier which can be used to correlate the stream with a <samp>CERTIFICATE_REQUEST</samp> frame received on stream zero.</p>
<p id="rfc.section.2.2.p.2">The <samp>CERTIFICATE_REQUIRED</samp> frame contains between 1 and 255 octets, which is the authentication request identifier.  A client that receives a <samp>CERTIFICATE_REQUIRED</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>.  Frames with identical request identifiers refer to the same <samp>CERTIFICATE_REQUEST</samp>.</p>
<p id="rfc.section.2.2.p.3">The <samp>CERTIFICATE_REQUIRED</samp> frame MUST NOT be sent by clients.  A <samp>CERTIFICATE_REQUIRED</samp> frame received by a server SHOULD be rejected with a stream error of type PROTOCOL_ERROR.</p>
<p id="rfc.section.2.2.p.4">The server MUST NOT send a <samp>CERTIFICATE_REQUIRED</samp> frame on stream zero, a server-initiated stream or a stream that does not have an outstanding request.  In other words, a server can only send in the &#8220;open&#8221; or &#8220;half-closed (remote)&#8221; stream states.</p>
<p id="rfc.section.2.2.p.5">A client that receives a <samp>CERTIFICATE_REQUIRED</samp> frame on a stream which is not in a valid state (&#8220;open&#8221; or &#8220;half-closed (local)&#8221; for clients) SHOULD treat this as a connection error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#http-certificate" id="http-certificate">The CERTIFICATE frame</a></h1>
<p id="rfc.section.2.3.p.1">The <samp>CERTIFICATE</samp> frame (0xFRAME-TBD3) allows the sender to provide elements of a certificate chain which can be used as authentication for previous or subsequent requests.</p>
<p id="rfc.section.2.3.p.2">The <samp>CERTIFICATE</samp> frame defines one flag:</p>
<p id="rfc.section.2.3.p.3">SOLICITED (0x01): : If set, indicates that the <samp>CERTIFICATE</samp> (and possibly <samp>CERTIFICATE_PROOF</samp>) frame(s) are being sent in response to a <samp>CERTIFICATE_REQUEST</samp> frame.</p>
<p id="rfc.section.2.3.p.4">The payload of a <samp>CERTIFICATE</samp> frame contains elements of a certificate chain, terminating in an end certificate. Multiple <samp>CERTIFICATE</samp> frames MAY be sent with the same Certificate-ID, to accomodate certificate chains which are too large to fit in a single HTTP/2 frame (see <a href="#RFC7540">[RFC7540]</a> section 4.2). The flag values MUST be identical for each <samp>CERTIFICATE</samp> frame sent with the same Certificate-ID.</p>
<p id="rfc.section.2.3.p.5">Particularly when a certificate contains a large number of Subject Alternative Names, it might not fit into a single <samp>CERTIFICATE</samp> frame even as the only provided certificate.  Senders unable to transfer a requested certificate due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp> value SHOULD increase their own <samp>SETTINGS_MAX_FRAME_SIZE</samp> to a size that would accomodate their certificate, then terminate affected streams with <samp>CERTIFICATE_TOO_LARGE</samp>.</p>
<p id="rfc.section.2.3.p.6">Use of the <samp>CERTIFICATE</samp> frame by servers is not defined by this document. A <samp>CERTIFICATE</samp> frame received by a client MUST be ignored.</p>
<p id="rfc.section.2.3.p.7">The <samp>CERTIFICATE</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.5"/>
<div id="fig-cert-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | ID-Length (8) |              Certificate-ID (*)             ...
 +-------------------------------+-------------------------------+
 | Cert-Count(8) |             Certificate-List (*)            ...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 5: CERTIFICATE frame payload</p>
<p id="rfc.section.2.3.p.8">The fields defined by the <samp>CERTIFICATE</samp> frame are:</p>
<p/>

<dl>
  <dt>ID-Length and Certificate-ID:</dt>
  <dd style="margin-left: 8">If the <samp>CERTIFICATE</samp> frame is in response to a <samp>CERTIFICATE_REQUEST</samp> from the server, the ID of that request.  Otherwise, a client-selected identifier for this certificate.  The identifier MUST be the output of a cryptographically-secure pseudo-random function.</dd>
  <dt>Cert-Count and Certificate-List:</dt>
  <dd style="margin-left: 8">A sequence of Certificate objects (see <a href="#cert-cert">Section 2.3.1</a>), each representing one certificate in the sender&#8217;s certificate chain. For the first or only <samp>CERTIFICATE</samp> frame with a given Certificate-ID, the sender&#8217;s certificate MUST be the first in the list. Each subsequent certificate SHOULD directly certify the certificate immediately preceding it. A certificate which specifies a trust anchor MAY be omitted, provided that the recipient is known to already possess the relevant certificate. (For example, because it was included in a <samp>CERTIFICATE_REQUEST</samp>&#8217;s Certificate-Authorities list.) <samp>Cert-Count</samp> describes the number of certificates provided.</dd>
</dl>
<p id="rfc.section.2.3.p.10">A <samp>CERTIFICATE</samp> frame with a <samp>Cert-Count</samp> of zero indicates a refusal of a <samp>CERTIFICATE_REQUEST</samp> &#8211; the sender either does not have or does not wish to provide a matching certificate. Servers SHOULD process all corresponding requests as unauthenticated, likely returning an authentication-related error at the HTTP level (e.g. 403).</p>
<p id="rfc.section.2.3.p.11">If the <samp>CERTIFICATE</samp> frame is sent without being requested, the <samp>SOLICITED</samp> flag MUST NOT be set. When the <samp>CERTIFICATE</samp> frame is sent in response to a <samp>CERTIFICATE_REQUEST</samp> frame, the <samp>SOLICITED</samp> flag MUST be set, and the <samp>Request-ID</samp> field MUST contain the same value as the corresponding <samp>CERTIFICATE_REQUEST</samp> frame. In this case, the provided certificate chain MUST conform to the requirements expressed in the <samp>CERTIFICATE_REQUEST</samp> to the best of the client&#8217;s ability. Specifically:</p>
<p/>

<ul>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Certificate-Authorities</samp> element, one of the certificates in the chain SHOULD be signed by one of the listed CAs.</li>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Cert-Extensions</samp> element, the first certificate MUST match with regard to the extension OIDs recognized by the client.</li>
  <li>Each certificate that is not self-signed MUST be signed using a hash/signature algorithm listed in the <samp>Algorithms</samp> element.</li>
</ul>
<p id="rfc.section.2.3.p.13">If these requirements are not satisfied, the server MAY at its discretion either process the request without client authentication, or respond with a stream error <a href="#RFC7540">[RFC7540]</a> on any stream where the certificate is used.  <a href="#errors">Section 3</a> defines certificate-related error codes which might be applicable.</p>
<h1 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1.</a> <a href="#cert-cert" id="cert-cert">The Certificate structure</a></h1>
<div id="rfc.figure.6"/>
<div id="fig-cert-cert"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |                    Cert-Length (24)           |    Cert (*) ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 6: Certificate structure</p>
<p id="rfc.section.2.3.1.p.1">The Certificate structure is a length-prefixed X.509v3 <a href="#RFC5280">[RFC5280]</a> certificate.  The certificate MUST be signed with an acceptable hash/signature algorithm pair, if the recipient&#8217;s list of acceptable pairs is known.</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#cert-proof" id="cert-proof">The CERTIFICATE_PROOF Frame</a></h1>
<p id="rfc.section.2.4.p.1">The <samp>CERTIFICATE_PROOF</samp> frame proves possession of the private key corresponding to an end certificate previously shown in a <samp>CERTIFICATE</samp> frame, along with its certificate chain in the same or other <samp>CERTIFICATE</samp> frames.</p>
<p id="rfc.section.2.4.p.2">The <samp>CERTIFICATE_PROOF</samp> frame defines two flags:</p>
<p/>

<dl>
  <dt>SOLICITED (0x01):</dt>
  <dd style="margin-left: 8">If set, indicates that the <samp>CERTIFICATE</samp> and <samp>CERTIFICATE_PROOF</samp> frames are being sent in response to a <samp>CERTIFICATE_REQUEST</samp> frame.</dd>
  <dt>AUTOMATIC_USE (0x02):</dt>
  <dd style="margin-left: 8">If set, the recipient SHOULD consider the certificate when authenticating future requests. Otherwise, the certificate MUST only be considered for requests on streams where a <samp>USE_CERTIFICATE</samp> frame (see <a href="#http-use-certificate">Section 2.5</a>) has been sent.</dd>
</dl>
<div id="rfc.figure.7"/>
<div id="fig-proof-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | ID-Length (8) |              Certificate-ID (*)             ...
 +-------------------------------+-------------------------------+
 |         Algorithm (16)        |         Sig-Length (16)       |
 +---------------------------------------------------------------+
 |                         Signature (*)                       ...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 7: CERTIFICATE_PROOF frame payload</p>
<p id="rfc.section.2.4.p.4">The <samp>CERTIFICATE_PROOF</samp> frame (0xFRAME-TBD4) contains an <samp>Algorithm</samp> field (a <samp>SignatureAndHashAlgorithm</samp>, from <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), describing the hash/signature algorithm pair being used. The signature is performed as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, with the following values being used:</p>
<p/>

<ul>
  <li>The context string for the signature is &#8220;HTTP/2 CERTIFICATE&#8221;</li>
  <li>The &#8220;specified content&#8221; is an <a href="#RFC5705">[RFC5705]</a> exported value, with the following parameters: <ul><li>Disambiguating label string: &#8220;EXPORTER HTTP/2 CERTIFICATE&#8221;</li><li>Context: The Certificate-ID chosen by the application</li><li>Length:  1024 bytes</li></ul></li>
</ul>
<p id="rfc.section.2.4.p.6">Because the exported value can be independently calculated by both sides of the TLS connection, the value to be signed is not sent on the wire at any time.</p>
<p id="rfc.section.2.4.p.7">A <samp>CERTIFICATE_PROOF</samp> frame MUST be sent only after all <samp>CERTIFICATE</samp> frames with the same Certificate-ID have been sent, and MUST correspond to the first certificate presented in the first <samp>CERTIFICATE</samp> frame with that Certificate-ID. Receipt of multiple <samp>CERTIFICATE_PROOF</samp> frames for the same Certificate-ID, receipt of a <samp>CERTIFICATE_PROOF</samp> frame without a corresponding <samp>CERTIFICATE</samp> frame, or receipt of a <samp>CERTIFICATE</samp> frame after a corresponding <samp>CERTIFICATE_PROOF</samp> MUST be treated as a session error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.2.4.p.8">Use of the <samp>CERTIFICATE_PROOF</samp> frame by servers is not defined by this document. A <samp>CERTIFICATE_PROOF</samp> frame received by a client MUST be ignored.</p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#http-use-certificate" id="http-use-certificate">The USE_CERTIFICATE Frame</a></h1>
<p id="rfc.section.2.5.p.1">The <samp>USE_CERTIFICATE</samp> frame (0xFRAME-TBD5) is sent by clients to indicate that processing of a request should use a certificate provided in a previous <samp>CERTIFICATE</samp> frame and proved by a preceding <samp>CERTIFICATE_PROOF</samp> frame. The frame includes a certificate identifier which can be used to correlate the stream with a <samp>CERTIFICATE</samp> frame received on stream zero.</p>
<p id="rfc.section.2.5.p.2">A <samp>USE_CERTIFICATE</samp> frame with no payload expresses the client&#8217;s choice to proceed without providing a certificate.  Servers SHOULD process the request as unauthenticated, likely returning an authentication-related error at the HTTP level (e.g. 403).</p>
<p id="rfc.section.2.5.p.3">Otherwise, the <samp>USE_CERTIFICATE</samp> frame contains between 1 and 255 octets, which is the authentication request identifier.  A server that receives a <samp>USE_CERTIFICATE</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>.  Frames with identical request identifiers refer to the same <samp>CERTIFICATE</samp>.</p>
<p id="rfc.section.2.5.p.4">Use of the <samp>USE_CERTIFICATE</samp> frame by servers is not defined by this document. A <samp>USE_CERTIFICATE</samp> frame received by a client MUST be ignored.</p>
<p id="rfc.section.2.5.p.5">The client MUST NOT send a <samp>USE_CERTIFICATE</samp> frame on stream zero, a server-initiated stream or a stream that does not have an outstanding request.  In other words, a client can only send in the &#8220;open&#8221; or &#8220;half-closed (local)&#8221; stream states.</p>
<p id="rfc.section.2.5.p.6">A server that receives a <samp>USE_CERTIFICATE</samp> frame on a stream which is not in a valid state (&#8220;open&#8221; or &#8220;half-closed (remote)&#8221; for servers) SHOULD treat this as a connection error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#errors" id="errors">Indicating failures during HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.3.p.1">Because this draft permits client certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p>
<p/>

<dl>
  <dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt>
  <dd style="margin-left: 8">A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
  <dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt>
  <dd style="margin-left: 8">A certificate was of an unsupported type</dd>
  <dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt>
  <dd style="margin-left: 8">A certificate was revoked by its signer</dd>
  <dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt>
  <dd style="margin-left: 8">A certificate has expired or is not currently valid</dd>
  <dt>BAD_SIGNATURE (0xERROR-TBD5):</dt>
  <dd style="margin-left: 8">The digital signature provided did not match</dd>
  <dt>CERTIFICATE_TOO_LARGE (0xERROR-TBD6):</dt>
  <dd style="margin-left: 8">The certificate cannot be transferred due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp></dd>
  <dt>CERTIFICATE_GENERAL (0xERROR-TBD7):</dt>
  <dd style="margin-left: 8">Any other certificate-related error</dd>
</dl>
<p id="rfc.section.3.p.3">As described in <a href="#RFC7540">[RFC7540]</a>, implementations MAY choose to treat a stream error as a connection error at any time.  Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <samp>CERTIFICATE_REQUEST</samp> and <samp>CERTIFICATE</samp> frames.  Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#setting" id="setting">Indicating Support for HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.4.p.1">Clients that support HTTP-layer certificate authentication indicate this using the HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> (0xSETTING-TBD) setting.</p>
<p id="rfc.section.4.p.2">The initial value for the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is 0, indicating that the client does not support reactive certificate authentication.  A client sets the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting to a value of 1 to indicate support for HTTP-layer certificate authentication as defined in this document.  Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1 of <a href="#RFC7540">[RFC7540]</a>) of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">Implementations need to be aware of the potential for confusion about the state of a connection.  Because a client&#8217;s unsolicited certificate might race with the server&#8217;s request for a certificate, failure to answer a <samp>CERTIFICATE_REQUEST</samp> is not necessarily an attack.  At the same time, failure to provide a certificate on a stream after receiving <samp>CERTIFICATE_REQUIRED</samp> blocks server processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p>
<p id="rfc.section.5.p.2">The presence or absence of a validated client certificate can change during the processing of a request, potentially multiple times.  A server that uses reactive certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.  This might occur without frames on-stream, if a <samp>CERTIFICATE</samp> frame with the <samp>AUTOMATIC_USE</samp> flag is received.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">The HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is registered in <a href="#iana-setting">Section 6.1</a>.  Four frame types are registered in <a href="#iana-frame">Section 6.2</a>.  Five error codes are registered in <a href="#iana-errors">Section 6.3</a>.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#iana-setting" id="iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></h1>
<p id="rfc.section.6.1.p.1">The SETTINGS_HTTP_CERT_AUTH setting is registered in the &#8220;HTTP/2 Settings&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">SETTINGS_HTTP_CERT_AUTH</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xSETTING-TBD</dd>
  <dt>Initial Value:</dt>
  <dd style="margin-left: 8">0</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#iana-frame" id="iana-frame">New HTTP/2 Frames</a></h1>
<p id="rfc.section.6.2.p.1">Four new frame types are registered in the &#8220;HTTP/2 Frame Types&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#certificaterequired" id="certificaterequired">CERTIFICATE_REQUIRED</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#certificaterequest" id="certificaterequest">CERTIFICATE_REQUEST</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUEST</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#certificate" id="certificate">CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#certificateproof" id="certificateproof">CERTIFICATE_PROOF</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_PROOF</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.5"><a href="#rfc.section.6.2.5">6.2.5.</a> <a href="#usecertificate" id="usecertificate">USE_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">USE_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#iana-errors" id="iana-errors">New HTTP/2 Error Codes</a></h1>
<p id="rfc.section.6.3.p.1">Five new error codes are registered in the &#8220;HTTP/2 Error Code&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#badcertificate" id="badcertificate">BAD_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> <a href="#unsupportedcertificate" id="unsupportedcertificate">UNSUPPORTED_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">UNSUPPORTED_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.3"><a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#certificaterevoked" id="certificaterevoked">CERTIFICATE_REVOKED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REVOKED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.4"><a href="#rfc.section.6.3.4">6.3.4.</a> <a href="#certificateexpired" id="certificateexpired">CERTIFICATE_EXPIRED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_EXPIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.5"><a href="#rfc.section.6.3.5">6.3.5.</a> <a href="#badsignature" id="badsignature">BAD_SIGNATURE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_SIGNATURE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.6"><a href="#rfc.section.6.3.6">6.3.6.</a> <a href="#certificategeneral" id="certificategeneral">CERTIFICATE_GENERAL</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_GENERAL</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD6</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.7.p.1">Eric Rescorla pointed out several failings in an earlier revision.  Andrei Popov contributed to the TLS considerations.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-10">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-10, October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X690">[X690]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a href="http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO ISO/IEC 8825-1:2002, 2002.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/martinthomson/http2-client-certs">Fork me on GitHub</a></div></div>
</body>
</html>
