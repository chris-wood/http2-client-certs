<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Reactive Certificate-Based Client Authentication in HTTP/2</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1000px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 700px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a:link, h2 a:link, h3 a:link, h4 a:link {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
table > thead > th {
  border-bottom: 2px solid #ddd;
}
table > tbody > tr > td, table > tbody > tr > th {
  border-top: 1px solid #ddd;
}
table > tbody > tr:nth-child(2n+1) > td,
table > tbody > tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.right {
  text-align: right;
}
td.reference {
  max-width: 200px;
}
td.right, td.left, td.reference, td.top {
  border-top: none;
}


table.header {
  width: 100%;
}
table.header > tbody > tr > td {
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p, #rfc\.abstract +p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
}

pre.text, pre.text2 {
  width: 90%;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
td.reference {
  padding-right: 1em;
  vertical-align: top;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a:link {
  color: #2a6496;
}
a:link:hover {
  background-color: #eee;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Reactive Certificate Authentication in HTTP/1.1"/>
<link href="#rfc.section.1.1.1" rel="Chapter" title="1.1.1 Using TLS 1.2 and previous"/>
<link href="#rfc.section.1.1.2" rel="Chapter" title="1.1.2 Using TLS 1.3"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Reactive Client Authentication in HTTP/2"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Presenting Client Certificates at the HTTP/2 Framing Layer"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 The CERTIFICATE_REQUIRED frame"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 The USE_CERTIFICATE Frame"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 The CERTIFICATE_REQUEST Frame"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 The CERTIFICATE frame"/>
<link href="#rfc.section.2.4.1" rel="Chapter" title="2.4.1 The Certificate structure"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 The CERTIFICATE_PROOF Frame"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Indicating failures during HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Indicating Support for HTTP-Layer Certificate Authentication"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 New HTTP/2 Frames"/>
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 CERTIFICATE_REQUIRED"/>
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 CERTIFICATE_REQUEST"/>
<link href="#rfc.section.6.2.3" rel="Chapter" title="6.2.3 CERTIFICATE"/>
<link href="#rfc.section.6.2.4" rel="Chapter" title="6.2.4 CERTIFICATE_PROOF"/>
<link href="#rfc.section.6.2.5" rel="Chapter" title="6.2.5 USE_CERTIFICATE"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 New HTTP/2 Error Codes"/>
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 BAD_CERTIFICATE"/>
<link href="#rfc.section.6.3.2" rel="Chapter" title="6.3.2 UNSUPPORTED_CERTIFICATE"/>
<link href="#rfc.section.6.3.3" rel="Chapter" title="6.3.3 CERTIFICATE_REVOKED"/>
<link href="#rfc.section.6.3.4" rel="Chapter" title="6.3.4 CERTIFICATE_EXPIRED"/>
<link href="#rfc.section.6.3.5" rel="Chapter" title="6.3.5 BAD_SIGNATURE"/>
<link href="#rfc.section.6.3.6" rel="Chapter" title="6.3.6 CERTIFICATE_GENERAL"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="8 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M. and M. Bishop" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-http2-client-certs-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-1-28" />
  <meta name="dct.abstract" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2." />
  <meta name="description" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">HTTP</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Expires: July 31, 2016</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">January 28, 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Reactive Certificate-Based Client Authentication in HTTP/2<br />
  <span class="filename">draft-thomson-http2-client-certs-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.  While TLS 1.3 provides an alternate mechanism to obtain client certificates, this mechanism does not map well to usage in TLS 1.2.</p>
<p>This document describes a how client authentication might be requested by a server as a result of receiving a request to a protected resource.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on July 31, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Reactive Certificate Authentication in HTTP/1.1</a></li>
<ul><li>1.1.1.   <a href="#rfc.section.1.1.1">Using TLS 1.2 and previous</a></li>
<li>1.1.2.   <a href="#rfc.section.1.1.2">Using TLS 1.3</a></li>
</ul><li>1.2.   <a href="#rfc.section.1.2">Reactive Client Authentication in HTTP/2</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Presenting Client Certificates at the HTTP/2 Framing Layer</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">The CERTIFICATE_REQUIRED frame</a></li>
<li>2.2.   <a href="#rfc.section.2.2">The USE_CERTIFICATE Frame</a></li>
<li>2.3.   <a href="#rfc.section.2.3">The CERTIFICATE_REQUEST Frame</a></li>
<li>2.4.   <a href="#rfc.section.2.4">The CERTIFICATE frame</a></li>
<ul><li>2.4.1.   <a href="#rfc.section.2.4.1">The Certificate structure</a></li>
</ul><li>2.5.   <a href="#rfc.section.2.5">The CERTIFICATE_PROOF Frame</a></li>
</ul><li>3.   <a href="#rfc.section.3">Indicating failures during HTTP-Layer Certificate Authentication</a></li>
<li>4.   <a href="#rfc.section.4">Indicating Support for HTTP-Layer Certificate Authentication</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></li>
<li>6.2.   <a href="#rfc.section.6.2">New HTTP/2 Frames</a></li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">CERTIFICATE_REQUIRED</a></li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">CERTIFICATE_REQUEST</a></li>
<li>6.2.3.   <a href="#rfc.section.6.2.3">CERTIFICATE</a></li>
<li>6.2.4.   <a href="#rfc.section.6.2.4">CERTIFICATE_PROOF</a></li>
<li>6.2.5.   <a href="#rfc.section.6.2.5">USE_CERTIFICATE</a></li>
</ul><li>6.3.   <a href="#rfc.section.6.3">New HTTP/2 Error Codes</a></li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">BAD_CERTIFICATE</a></li>
<li>6.3.2.   <a href="#rfc.section.6.3.2">UNSUPPORTED_CERTIFICATE</a></li>
<li>6.3.3.   <a href="#rfc.section.6.3.3">CERTIFICATE_REVOKED</a></li>
<li>6.3.4.   <a href="#rfc.section.6.3.4">CERTIFICATE_EXPIRED</a></li>
<li>6.3.5.   <a href="#rfc.section.6.3.5">BAD_SIGNATURE</a></li>
<li>6.3.6.   <a href="#rfc.section.6.3.6">CERTIFICATE_GENERAL</a></li>
</ul></ul><li>7.   <a href="#rfc.section.7">Acknowledgements</a></li>
<li>8.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Many existing HTTP <a href="#RFC7230">[RFC7230]</a> servers have different authentication requirements for the different resources they serve.  Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS <a href="#I-D.ietf-tls-tls13">RFC5246</a> <cite title="NONE">[I-D.ietf-tls-tls13]</cite> layer.</p>
<p id="rfc.section.1.p.2">For servers that wish to use client certificates to authenticate users, they might request client authentication during or immediately after the TLS handshake.  However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate.  Such a request can result in a poor experience, particularly when sent to a client that does not expect the request.</p>
<p id="rfc.section.1.p.3">The TLS 1.3 CertificateRequest can be used by servers to give clients hints about which certificate to offer.  Servers that rely on certificate-based authentication might request different certificates for different resources.  Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p>
<p id="rfc.section.1.p.4">Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources.  Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p>
<p id="rfc.section.1.p.5">In Yokohama, there was extensive working group discussion regarding why certificate authentication could not easily be done at the HTTP semantic layer.  However, in subsequent discussion, it became apparent that the HTTP <em>framing</em> layer did not suffer from the same limitation.</p>
<p id="rfc.section.1.p.6">In this document, a mechanism for doing certificate-based client authentication via HTTP/2 frames is defined.  This mechanism can be implemented at the HTTP layer without requiring new TLS stack behavior and without breaking the existing interface between HTTP and applications which employ client certificates.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#reactive-certificate-authentication-in-http11" id="reactive-certificate-authentication-in-http11">Reactive Certificate Authentication in HTTP/1.1</a></h1>
<h1 id="rfc.section.1.1.1"><a href="#rfc.section.1.1.1">1.1.1.</a> <a href="#using-tls-12-and-previous" id="using-tls-12-and-previous">Using TLS 1.2 and previous</a></h1>
<p id="rfc.section.1.1.1.p.1">In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established.  Instead, it only requests a client certificate when a request is made to a resource that requires a certificate.  TLS 1.2 <a href="#RFC5246">[RFC5246]</a> accomodates this by permitting the server to request a new TLS handshake, in which the server will request the client&#8217;s certificate.</p>
<p><a href="#ex-http11">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p>
<div id="rfc.figure.1"/>
<div id="ex-http11"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre>
<p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p>
<p id="rfc.section.1.1.1.p.3">In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure 1</a>).  Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p>
<p id="rfc.section.1.1.1.p.4">The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2).  The client then initiates a TLS handshake.  Note that some TLS messages are elided from the figure for the sake of brevity.</p>
<p id="rfc.section.1.1.1.p.5">The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource.  The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p>
<p id="rfc.section.1.1.1.p.6">When the handshake completes, the server performs any authorization checks a second time.  With the client certificate available, it then authorizes the request and provides a response (*5).</p>
<h1 id="rfc.section.1.1.2"><a href="#rfc.section.1.1.2">1.1.2.</a> <a href="#using-tls-13" id="using-tls-13">Using TLS 1.3</a></h1>
<p id="rfc.section.1.1.2.p.1">TLS 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed.  For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation.  <a href="#ex-tls13">Figure 2</a> shows the simpler exchange this enables.</p>
<div id="rfc.figure.2"/>
<div id="ex-tls13"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate, CertificateVerify ----&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre>
<p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p>
<p id="rfc.section.1.1.2.p.2">TLS 1.3 does not support renegotiation, instead supporting direct client authentication.  In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#reactive-client-authentication-in-http2" id="reactive-client-authentication-in-http2">Reactive Client Authentication in HTTP/2</a></h1>
<p id="rfc.section.1.2.p.1">An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation.  The client is able to assume that the next unanswered request on the connection is responsible.  The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request.  This ensures that the application has the right contextual information for processing the request.</p>
<p id="rfc.section.1.2.p.2">In HTTP/2, a client can have multiple outstanding requests.  Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p>
<p id="rfc.section.1.2.p.3">Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with a request for a certificate.</p>
<p id="rfc.section.1.2.p.4">Such an identifier could be added to TLS 1.2 by means of an extension, but many TLS 1.2 implementations do not permit application data to continue during a renegotiation. This is problematic for a multiplexed protocol like HTTP/2. Instead, this draft proposes bringing the TLS 1.3 CertificateRequest, Certificate, and CertificateVerify messages into HTTP/2 frames, making client certificate authentication TLS-version-agnostic.</p>
<p id="rfc.section.1.2.p.5">This could be done in a naive manner by replicating the messages as HTTP/2 frames on each stream. However, this would create needless redundancy between streams and require frequent expensive signing operations. Instead, this draft lifts the bulky portions of each message into frames on stream zero and permits the on-stream frames to incorporate them by reference as needed.</p>
<p id="rfc.section.1.2.p.6">On each stream where certificate authentication is required, the server sends a <samp>CERTIFICATE_REQUIRED</samp> frame, which the client answers with a <samp>USE_CERTIFICATE</samp> frame either indicating the certificate to use, or indicating that no certificate should be used. These frames are simple, referencing information previously sent on stream zero to reduce redundancy.</p>
<p><samp>CERTIFICATE_REQUIRED</samp> frames reference a <samp>CERTIFICATE_REQUEST</samp> on stream zero, analogous to the CertificateRequest message.  <samp>USE_CERTIFICATE</samp> frames reference a sequence of <samp>CERTIFICATE</samp> and <samp>CERTIFICATE_PROOF</samp> frames on stream zero, analogous to the the Certificate and CertificateVerify messages.</p>
<p id="rfc.section.1.2.p.8">The exchange then looks like this:</p>
<div id="rfc.figure.3"/>
<div id="ex-http2"/>
<pre>
Client                                      Server
   -- (streams 1,3) GET /protected ------------&gt;
   &lt;---------- (stream 0) CERTIFICATE_REQUEST --
   &lt;------ (streams 1,3) CERTIFICATE_REQUIRED --
   -- (stream 0) CERTIFICATE ------------------&gt;
   -- (stream 0) CERTIFICATE_PROOF ------------&gt;
   -- (streams 1,3) USE_CERTIFICATE -----------&gt;
   &lt;-------------------- (streams 1,3) 200 OK --
   
</pre>
<p class="figure">Figure 3: HTTP/2 Reactive Certificate Authentication</p>
<p id="rfc.section.1.2.p.9">To avoid the extra round-trip per stream required for a challenge and response, the <samp>AUTOMATIC_USE</samp> flag enables a certificate to be automatically used by the server on subsequent requests without sending a <samp>CERTIFICATE_REQUIRED</samp> exchange.</p>
<p><a href="#certs-http2">Section 2</a> describes how certificates can be requested and presented at the HTTP/2 framing layer using several new frame types which parallel the TLS 1.3 message exchange.  <a href="#errors">Section 3</a> defines new error types which can be used to notify peers when the exchange has not been successful.  Finally, <a href="#setting">Section 4</a> describes how an HTTP/2 client can announce support for this feature so that a server might use these capabilities.</p>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.1.3.p.1">RFC 2119 <a href="#RFC2119">[RFC2119]</a> defines the terms &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221; and &#8220;MAY&#8221;.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#certs-http2" id="certs-http2">Presenting Client Certificates at the HTTP/2 Framing Layer</a></h1>
<p id="rfc.section.2.p.1">An HTTP/2 request from a client that has signaled support for reactive certificate authentication (see <a href="#setting">Section 4</a>) might cause a server to request client authentication.  In HTTP/2 a server does this by sending at least one <samp>CERTIFICATE_REQUEST</samp> frame (see <a href="#http-cert-request">Section 2.3</a>) on stream zero and sending a <samp>CERTIFICATE_REQUIRED</samp> frame (see <a href="#http-cert-required">Section 2.1</a>) on the affected stream(s).  The <samp>CERTIFICATE_REQUEST</samp> and <samp>CERTIFICATE_REQUIRED</samp> frames are correlated by their <samp>Request-ID</samp> field. Subsequent <samp>CERTIFICATE_REQUIRED</samp> frames with the same Request-ID MAY be sent on other streams where the server is expecting client authentication with the same parameters.</p>
<p id="rfc.section.2.p.2">A server MAY send multiple concurrent <samp>CERTIFICATE_REQUIRED</samp> frames on the same stream. If a server requires that a client provide multiple certificates before authorizing a single request, it MUST send a <samp>CERTIFICATE_REQUIRED</samp> frame with a different request identifier and a corresponding <samp>CERTIFICATE_REQUEST</samp> frame describing each required certificate.</p>
<p id="rfc.section.2.p.3">Clients respond to requests by sending one or more <samp>CERTIFICATE</samp> frames (see <a href="#http-certificate">Section 2.4</a>), followed by a <samp>CERTIFICATE_PROOF</samp> frame (see <a href="#cert-proof">Section 2.5</a>), on stream zero containing the <samp>Request-ID</samp> to which they are responding. The <samp>USE_CERTIFICATE</samp> (see <a href="#http-use-certificate">Section 2.2</a>) frame is sent on-stream to notify the server the stream is ready to be processed.</p>
<p id="rfc.section.2.p.4">To reduce round-trips, the client MAY set the <samp>AUTOMATIC_USE</samp> flag on a <samp>CERTIFICATE_PROOF</samp> frame, indicating that the server SHOULD automatically apply the supplied certificate to any future streams matching that request, rather than sending a <samp>CERTIFICATE_REQUIRED</samp> frame.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#http-cert-required" id="http-cert-required">The CERTIFICATE_REQUIRED frame</a></h1>
<p id="rfc.section.2.1.p.1">The <samp>CERTIFICATE_REQUIRED</samp> frame (0xFRAME-TBD2) is sent by servers to indicate that processing of an HTTP request is blocked pending certificate authentication. The frame includes a request identifier which can be used to correlate the stream with a previous <samp>CERTIFICATE_REQUEST</samp> frame received on stream zero. The <samp>CERTIFICATE_REQUEST</samp> describes the client certificate the server requires to process the request.</p>
<p id="rfc.section.2.1.p.2">The <samp>CERTIFICATE_REQUIRED</samp> frame contains 1 octet, which is the authentication request identifier. A client that receives a <samp>CERTIFICATE_REQUIRED</samp> of any other length MUST treat this as a stream error of type <samp>PROTOCOL_ERROR</samp>. Frames with identical request identifiers refer to the same <samp>CERTIFICATE_REQUEST</samp>.</p>
<p id="rfc.section.2.1.p.3">The <samp>CERTIFICATE_REQUIRED</samp> frame MUST NOT be sent by clients. A <samp>CERTIFICATE_REQUIRED</samp> frame received by a server SHOULD be rejected with a stream error of type PROTOCOL_ERROR.</p>
<p id="rfc.section.2.1.p.4">The server MUST NOT send a <samp>CERTIFICATE_REQUIRED</samp> frame on stream zero, a server-initiated stream or a stream that does not have an outstanding request.  In other words, a server can only send in the &#8220;open&#8221; or &#8220;half-closed (remote)&#8221; stream states.</p>
<p id="rfc.section.2.1.p.5">A client that receives a <samp>CERTIFICATE_REQUIRED</samp> frame on a stream which is not in a valid state (&#8220;open&#8221; or &#8220;half-closed (local)&#8221; for clients) SHOULD treat this as a connection error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#http-use-certificate" id="http-use-certificate">The USE_CERTIFICATE Frame</a></h1>
<p id="rfc.section.2.2.p.1">The <samp>USE_CERTIFICATE</samp> frame (0xFRAME-TBD5) is sent by clients in response to a <samp>CERTIFICATE_REQUIRED</samp> frame to indicate that the requested certificate has been provided (or will not be).</p>
<p id="rfc.section.2.2.p.2">A <samp>USE_CERTIFICATE</samp> frame with no payload expresses the client&#8217;s refusal to use the associated certificate (if any) with this stream. If the request was originally issued for a different stream, servers MAY create a new <samp>CERTIFICATE_REQUEST</samp> and permit the client to offer a different certificate. Alternatively, servers MAY process the request as unauthenticated, likely returning an authentication-related error at the HTTP level (e.g. 403).</p>
<p id="rfc.section.2.2.p.3">Otherwise, the <samp>USE_CERTIFICATE</samp> frame contains the <samp>Request-ID</samp> of the now-completed certificate request. This MUST be an ID previously issued by the server, and for which a matching certificate has previously been presented along with a supporting certificate chain in one or more <samp>CERTIFICATE</samp> frames, and for which proof of possession has been presented in a <samp>CERTIFICATE_PROOF</samp> frame.</p>
<p id="rfc.section.2.2.p.4">Use of the <samp>USE_CERTIFICATE</samp> frame by servers is not defined by this document. A <samp>USE_CERTIFICATE</samp> frame received by a client MUST be ignored.</p>
<p id="rfc.section.2.2.p.5">The client MUST NOT send a <samp>USE_CERTIFICATE</samp> frame on stream zero, a server-initiated stream or a stream that does not have an outstanding request. In other words, a client can only send in the &#8220;open&#8221; or &#8220;half-closed (local)&#8221; stream states. The client MUST NOT send a <samp>USE_CERTIFICATE</samp> frame except in response to a <samp>CERTIFICATE_REQUIRED</samp> frame from the server.</p>
<p id="rfc.section.2.2.p.6">A server that receives a <samp>USE_CERTIFICATE</samp> frame on a stream which is not in a valid state (&#8220;open&#8221; or &#8220;half-closed (remote)&#8221; for servers), on which it has not sent a <samp>CERTIFICATE_REQUIRED</samp> frame, or referencing a certificate it has not previously received SHOULD treat this as a connection error of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#http-cert-request" id="http-cert-request">The CERTIFICATE_REQUEST Frame</a></h1>
<p id="rfc.section.2.3.p.1">TLS 1.3 defines the <samp>CertificateRequest</samp> message, which prompts the client to provide a certificate which conforms to certain properties specified by the server.  This draft defines the <samp>CERTIFICATE_REQUEST</samp> frame (0xFRAME-TBD1), which contains the same contents as a TLS 1.3 <samp>CertificateRequest</samp> message, but can be sent over any TLS version.</p>
<p id="rfc.section.2.3.p.2">The <samp>CERTIFICATE_REQUEST</samp> frame MUST NOT be sent by clients.  A <samp>CERTIFICATE_REQUEST</samp> frame received by a server SHOULD be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.2.3.p.3">The <samp>CERTIFICATE_REQUEST</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE_REQUEST</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.4"/>
<div id="fig-cert-request"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|     Algorithm-Count (16)      | Algorithms  ...
 +---------------------------------------------------------------+
 |       CA-Count (16)           |  Certificate-Authorities(?) ...
 +---------------------------------------------------------------+
 |   Cert-Extension-Count (16)   |       Cert-Extensions(?)    ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 4: CERTIFICATE_REQUEST frame payload</p>
<p id="rfc.section.2.3.p.4">The frame contains the following fields:</p>
<p/>

<dl>
  <dt>Request-ID:</dt>
  <dd style="margin-left: 8"><samp>Request-ID</samp> is an 8-bit opaque identifier used to correlate subsequent certificate-related frames with this request.  The identifier MUST be unique in the session.</dd>
  <dt>Algorithm-Count and Algorithms:</dt>
  <dd style="margin-left: 8">A list of the hash/signature algorithm pairs that the server is able to verify, listed in descending order of preference. Any certificates provided by the client MUST be signed using a hash/signature algorithm pair found in <samp>Algorithms</samp>. Each algorithm pair is encoded as a <samp>SignatureAndHashAlgorithm</samp> (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), and the number of such structures is given by the 16-bit <samp>Algorithm-Count</samp> field, which MUST NOT be zero.</dd>
  <dt>CA-Count and Certificate-Authorities:</dt>
  <dd style="margin-left: 8"><samp>Certificate-Authorities</samp> is a series of distinguished names of acceptable certificate authorities, represented in DER-encoded <a href="#X690">[X690]</a> format.  These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space. The number of such structures is given by the 16-bit <samp>CA-Count</samp> field, which MAY be zero. If the <samp>CA-Count</samp> field is zero, then the client MAY send any certificate that meets the rest of the selection criteria in the <samp>CERTIFICATE_REQUEST</samp>, unless there is some external arrangement to the contrary.</dd>
  <dt>Cert-Extension-Count and Cert-Extensions:</dt>
  <dd style="margin-left: 8">A list of certificate extension OIDs <a href="#RFC5280">[RFC5280]</a> with their allowed values, represented in a series of <samp>CertificateExtension</samp> structures (see <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.5). The list of OIDs MUST be used in certificate selection as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>. The number of Cert-Extension structures is given by the 16-bit <samp>Cert-Extension-Count</samp> field, which MAY be zero.</dd>
</dl>
<p id="rfc.section.2.3.p.6">Some certificate extension OIDs allow multiple values (e.g. Extended Key Usage). If the sender has included a non-empty certificate_extensions list, the certificate MUST contain all of the specified extension OIDs that the recipient recognizes. For each extension OID recognized by the recipient, all of the specified values MUST be present in the certificate (but the certificate MAY have other values as well).  However, the recipient MUST ignore and skip any unrecognized certificate extension OIDs.</p>
<p id="rfc.section.2.3.p.7">PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that implementations will rely on their PKI libraries to perform certificate selection using these certificate extension OIDs.</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#http-certificate" id="http-certificate">The CERTIFICATE frame</a></h1>
<p id="rfc.section.2.4.p.1">A certificate chain is transferred as a series of <samp>CERTIFICATE</samp> frames (0xFRAME-TBD3) with the same Request-ID, each containing a single certificate in the chain. The end certificate of the chain can be used as authentication for previous or subsequent requests.</p>
<p id="rfc.section.2.4.p.2">The <samp>CERTIFICATE</samp> frame defines no flags.</p>
<p id="rfc.section.2.4.p.3">While unlikely, it is possible that an exceptionally large certificate might be too large to fit in a single HTTP/2 frame (see <a href="#RFC7540">[RFC7540]</a> section 4.2). Senders unable to transfer a requested certificate due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp> value SHOULD terminate affected streams with <samp>CERTIFICATE_TOO_LARGE</samp>.</p>
<p id="rfc.section.2.4.p.4">Use of the <samp>CERTIFICATE</samp> frame by servers is not defined by this document. A <samp>CERTIFICATE</samp> frame received by a client MUST be ignored.</p>
<p id="rfc.section.2.4.p.5">The <samp>CERTIFICATE</samp> frame MUST be sent on stream zero.  A <samp>CERTIFICATE</samp> frame received on any other stream MUST be rejected with a stream error of type <samp>PROTOCOL_ERROR</samp>.</p>
<div id="rfc.figure.5"/>
<div id="fig-cert-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|                Certificate (*)              ...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 5: CERTIFICATE frame payload</p>
<p id="rfc.section.2.4.p.6">The fields defined by the <samp>CERTIFICATE</samp> frame are:</p>
<p/>

<dl>
  <dt>Request-ID:</dt>
  <dd style="margin-left: 8">The ID of the <samp>CERTIFICATE_REQUEST</samp> to which this frame responds.</dd>
  <dt>Certificate:</dt>
  <dd style="margin-left: 8">A Certificate object (see <a href="#cert-cert">Section 2.4.1</a>) representing one certificate in the sender&#8217;s certificate chain. The first or only <samp>CERTIFICATE</samp> frame with a given Request-ID MUST contain the sender&#8217;s certificate. Each subsequent certificate SHOULD directly certify the certificate immediately preceding it. A certificate which specifies a trust anchor MAY be omitted, provided that the recipient is known to already possess the relevant certificate. (For example, because it was included in a <samp>CERTIFICATE_REQUEST</samp>&#8217;s Certificate-Authorities list.)</dd>
</dl>
<p id="rfc.section.2.4.p.8">The <samp>Request-ID</samp> field MUST contain the same value as the corresponding <samp>CERTIFICATE_REQUEST</samp> frame, and the provided certificate chain MUST conform to the requirements expressed in the <samp>CERTIFICATE_REQUEST</samp> to the best of the client&#8217;s ability. Specifically:</p>
<p/>

<ul>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Certificate-Authorities</samp> element, one of the certificates in the chain SHOULD be signed by one of the listed CAs.</li>
  <li>If the <samp>CERTIFICATE_REQUEST</samp> contained a non-empty <samp>Cert-Extensions</samp> element, the first certificate MUST match with regard to the extension OIDs recognized by the client.</li>
  <li>Each certificate that is not self-signed MUST be signed using a hash/signature algorithm listed in the <samp>Algorithms</samp> element.</li>
</ul>
<p id="rfc.section.2.4.p.10">If these requirements are not satisfied, the server MAY at its discretion either process the request without client authentication, or respond with a stream error <a href="#RFC7540">[RFC7540]</a> on any stream where the certificate is used.  <a href="#errors">Section 3</a> defines certificate-related error codes which might be applicable.</p>
<p id="rfc.section.2.4.p.11">A client cannot provide different certificates in response to the same <samp>CERTIFICATE_REQUEST</samp> for use on different streams.  A client that has already sent and proven a certificate, but does not wish to use it on a particular stream SHOULD send an empty <samp>USE_CERTIFICATE</samp> frame, refusing to use that certificate on that stream.</p>
<h1 id="rfc.section.2.4.1"><a href="#rfc.section.2.4.1">2.4.1.</a> <a href="#cert-cert" id="cert-cert">The Certificate structure</a></h1>
<div id="rfc.figure.6"/>
<div id="fig-cert-cert"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 |                    Cert-Length (24)           |    Cert (*) ...
 +---------------------------------------------------------------+
</pre>
<p class="figure">Figure 6: Certificate structure</p>
<p id="rfc.section.2.4.1.p.1">The Certificate structure is a length-prefixed X.509v3 <a href="#RFC5280">[RFC5280]</a> certificate.  The certificate MUST be signed with an acceptable hash/signature algorithm pair, if the recipient&#8217;s list of acceptable pairs is known.</p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#cert-proof" id="cert-proof">The CERTIFICATE_PROOF Frame</a></h1>
<p id="rfc.section.2.5.p.1">The <samp>CERTIFICATE_PROOF</samp> frame proves possession of the private key corresponding to an end certificate previously shown in a <samp>CERTIFICATE</samp> frame, along with its certificate chain in the same or other <samp>CERTIFICATE</samp> frames.</p>
<p id="rfc.section.2.5.p.2">The <samp>CERTIFICATE_PROOF</samp> frame defines one flag:</p>
<p/>

<dl>
  <dt>AUTOMATIC_USE (0x01):</dt>
  <dd style="margin-left: 8">Indicates that the certificate can be used automatically on future requests.</dd>
</dl>
<div id="rfc.figure.7"/>
<div id="fig-proof-frame"/>
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-------------------------------+-------------------------------+
 | Request-ID (8)|         Algorithm (16)        | Signature(*)...
 +---------------------------------------------------------------+
 
</pre>
<p class="figure">Figure 7: CERTIFICATE_PROOF frame payload</p>
<p id="rfc.section.2.5.p.4">The <samp>CERTIFICATE_PROOF</samp> frame (0xFRAME-TBD4) contains an <samp>Algorithm</samp> field (a <samp>SignatureAndHashAlgorithm</samp>, from <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> section 6.3.2.1), describing the hash/signature algorithm pair being used. The signature is performed as described in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a>, with the following values being used:</p>
<p/>

<ul>
  <li>The context string for the signature is &#8220;HTTP/2 CERTIFICATE_PROOF&#8221;</li>
  <li>The &#8220;specified content&#8221; is an <a href="#RFC5705">[RFC5705]</a> exported value, with the following parameters: <ul><li>Disambiguating label string: &#8220;EXPORTER HTTP/2 CERTIFICATE_PROOF&#8221;</li><li>Length:  64 bytes</li></ul></li>
</ul>
<p id="rfc.section.2.5.p.6">Because the exported value can be independently calculated by both sides of the TLS connection, the value to be signed is not sent on the wire at any time.  The same signed value is used for all <samp>CERTIFICATE_PROOF</samp> frames in a single HTTP/2 connection.</p>
<p id="rfc.section.2.5.p.7">A <samp>CERTIFICATE_PROOF</samp> frame MUST be sent only after all <samp>CERTIFICATE</samp> frames with the same Request-ID have been sent, and MUST correspond to the first certificate presented in the first <samp>CERTIFICATE</samp> frame with that Request-ID. Receipt of multiple <samp>CERTIFICATE_PROOF</samp> frames for the same Request-ID, receipt of a <samp>CERTIFICATE_PROOF</samp> frame without a corresponding <samp>CERTIFICATE</samp> frame, or receipt of a <samp>CERTIFICATE</samp> frame after a corresponding <samp>CERTIFICATE_PROOF</samp> MUST be treated as a session error of type <samp>PROTOCOL_ERROR</samp>.</p>
<p id="rfc.section.2.5.p.8">If the <samp>AUTOMATIC_USE</samp> flag is set, the server MAY omit sending <samp>CERTIFICATE_REQUIRED</samp> frames on future streams associated with this request and use the referenced certificate for authentication without further notice to the client. This behavior is optional, and receipt of a <samp>CERTIFICATE_REQUIRED</samp> frame does not imply that previously-presented certificates were unacceptable to the server.</p>
<p id="rfc.section.2.5.p.9">Use of the <samp>CERTIFICATE_PROOF</samp> frame by servers is not defined by this document. A <samp>CERTIFICATE_PROOF</samp> frame received by a client MUST be ignored.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#errors" id="errors">Indicating failures during HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.3.p.1">Because this draft permits client certificates to be exchanged at the HTTP framing layer instead of the TLS layer, several certificate-related errors which are defined at the TLS layer might now occur at the HTTP framing layer. In this section, those errors are restated and added to the HTTP/2 error code registry.</p>
<p/>

<dl>
  <dt>BAD_CERTIFICATE (0xERROR-TBD1):</dt>
  <dd style="margin-left: 8">A certificate was corrupt, contained signatures that did not verify correctly, etc.</dd>
  <dt>UNSUPPORTED_CERTIFICATE (0xERROR-TBD2):</dt>
  <dd style="margin-left: 8">A certificate was of an unsupported type or did not contain required extensions</dd>
  <dt>CERTIFICATE_REVOKED (0xERROR-TBD3):</dt>
  <dd style="margin-left: 8">A certificate was revoked by its signer</dd>
  <dt>CERTIFICATE_EXPIRED (0xERROR-TBD4):</dt>
  <dd style="margin-left: 8">A certificate has expired or is not currently valid</dd>
  <dt>BAD_SIGNATURE (0xERROR-TBD5):</dt>
  <dd style="margin-left: 8">The digital signature provided did not match</dd>
  <dt>CERTIFICATE_TOO_LARGE (0xERROR-TBD6):</dt>
  <dd style="margin-left: 8">The certificate cannot be transferred due to the recipient&#8217;s <samp>SETTINGS_MAX_FRAME_SIZE</samp></dd>
  <dt>CERTIFICATE_GENERAL (0xERROR-TBD7):</dt>
  <dd style="margin-left: 8">Any other certificate-related error</dd>
</dl>
<p id="rfc.section.3.p.3">As described in <a href="#RFC7540">[RFC7540]</a>, implementations MAY choose to treat a stream error as a connection error at any time.  Of particular note, a stream error cannot occur on stream 0, which means that implementations cannot send non-session errors in response to <samp>CERTIFICATE_REQUEST</samp> and <samp>CERTIFICATE</samp> frames.  Implementations which do not wish to terminate the connection MAY either send relevant errors on any stream which references the failing certificate in question or process the requests as unauthenticated and provide error information at the HTTP semantic layer.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#setting" id="setting">Indicating Support for HTTP-Layer Certificate Authentication</a></h1>
<p id="rfc.section.4.p.1">Clients that support HTTP-layer certificate authentication indicate this using the HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> (0xSETTING-TBD) setting.</p>
<p id="rfc.section.4.p.2">The initial value for the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is 0, indicating that the client does not support reactive certificate authentication.  A client sets the <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting to a value of 1 to indicate support for HTTP-layer certificate authentication as defined in this document.  Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1 of <a href="#RFC7540">[RFC7540]</a>) of type <samp>PROTOCOL_ERROR</samp>.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">Failure to provide a certificate on a stream after receiving <samp>CERTIFICATE_REQUIRED</samp> blocks server processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.</p>
<p id="rfc.section.5.p.2">In order to protect the privacy of the connection against triple-handshake attacks, this feature of HTTP/2 MUST be used only over TLS 1.3 or greater, or over TLS 1.2 in combination with the Extended Master Secret extension defined in <a href="#RFC7627">[RFC7627]</a>. Because this feature is intended to operate with equivalent security to the TLS connection, hash and signature algorithms not permitted by the version of TLS in use MUST NOT be used. Additionally, the following algorithms MUST NOT be used, even if permitted by the underlying TLS version:</p>
<p/>

<ul>
  <li>MD5</li>
  <li>SHA1</li>
  <li>SHA224</li>
  <li>DSA</li>
  <li>ECDSA with curves on prime fields that are less than 240 bits wide</li>
  <li>RSA with a prime modulus less than 2048 bits</li>
</ul>
<p id="rfc.section.5.p.4">Client implementations need to carefully consider the impact of setting the <samp>AUTOMATIC_USE</samp> flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication. However, once this flag has been sent, the client has zero knowledge about whether the server will use the referenced cert for any future request, or even for an existing request which has not yet completed. Clients MUST NOT set this flag on any certificate which is not appropriate for currently-in-flight requests, and MUST NOT make any future requests on the same connection which they do not intend to have associated with the provided certificate.</p>
<p id="rfc.section.5.p.5">Implementations need to be aware of the potential for confusion about the state of a connection. The presence or absence of a validated client certificate can change during the processing of a request, potentially multiple times, as <samp>USE_CERTIFICATE</samp> frames are received. A server that uses certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">The HTTP/2 <samp>SETTINGS_HTTP_CERT_AUTH</samp> setting is registered in <a href="#iana-setting">Section 6.1</a>.  Five frame types are registered in <a href="#iana-frame">Section 6.2</a>.  Six error codes are registered in <a href="#iana-errors">Section 6.3</a>.</p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#iana-setting" id="iana-setting">HTTP/2 SETTINGS_HTTP_CERT_AUTH Setting</a></h1>
<p id="rfc.section.6.1.p.1">The SETTINGS_HTTP_CERT_AUTH setting is registered in the &#8220;HTTP/2 Settings&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">SETTINGS_HTTP_CERT_AUTH</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xSETTING-TBD</dd>
  <dt>Initial Value:</dt>
  <dd style="margin-left: 8">0</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#iana-frame" id="iana-frame">New HTTP/2 Frames</a></h1>
<p id="rfc.section.6.2.p.1">Four new frame types are registered in the &#8220;HTTP/2 Frame Types&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.2.1"><a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#certificaterequired" id="certificaterequired">CERTIFICATE_REQUIRED</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.2"><a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#certificaterequest" id="certificaterequest">CERTIFICATE_REQUEST</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REQUEST</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.3"><a href="#rfc.section.6.2.3">6.2.3.</a> <a href="#certificate" id="certificate">CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.4"><a href="#rfc.section.6.2.4">6.2.4.</a> <a href="#certificateproof" id="certificateproof">CERTIFICATE_PROOF</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">CERTIFICATE_PROOF</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.2.5"><a href="#rfc.section.6.2.5">6.2.5.</a> <a href="#usecertificate" id="usecertificate">USE_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Frame Type:</dt>
  <dd style="margin-left: 8">USE_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xFRAME-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#iana-errors" id="iana-errors">New HTTP/2 Error Codes</a></h1>
<p id="rfc.section.6.3.p.1">Five new error codes are registered in the &#8220;HTTP/2 Error Code&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<h1 id="rfc.section.6.3.1"><a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#badcertificate" id="badcertificate">BAD_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD1</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.2"><a href="#rfc.section.6.3.2">6.3.2.</a> <a href="#unsupportedcertificate" id="unsupportedcertificate">UNSUPPORTED_CERTIFICATE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">UNSUPPORTED_CERTIFICATE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD2</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.3"><a href="#rfc.section.6.3.3">6.3.3.</a> <a href="#certificaterevoked" id="certificaterevoked">CERTIFICATE_REVOKED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_REVOKED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD3</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.4"><a href="#rfc.section.6.3.4">6.3.4.</a> <a href="#certificateexpired" id="certificateexpired">CERTIFICATE_EXPIRED</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_EXPIRED</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD4</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.5"><a href="#rfc.section.6.3.5">6.3.5.</a> <a href="#badsignature" id="badsignature">BAD_SIGNATURE</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">BAD_SIGNATURE</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD5</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.6.3.6"><a href="#rfc.section.6.3.6">6.3.6.</a> <a href="#certificategeneral" id="certificategeneral">CERTIFICATE_GENERAL</a></h1>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">CERTIFICATE_GENERAL</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xERROR-TBD6</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.7.p.1">Eric Rescorla pointed out several failings in an earlier revision.  Andrei Popov contributed to the TLS considerations.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-11">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-11, December 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5280">[RFC5280]</b>
      </td>
      <td class="top"><a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7627">[RFC7627]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/rfc7627">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", RFC 7627, DOI 10.17487/RFC7627, September 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="X690">[X690]</b>
      </td>
      <td class="top"><a>ITU-T</a>, "<a href="http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a>", ISO ISO/IEC 8825-1:2002, 2002.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/martinthomson/http2-client-certs">Fork me on GitHub</a></div></div>
</body>
</html>
