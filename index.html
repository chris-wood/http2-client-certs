<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Reactive Certificate-Based Client Authentication in HTTP/2</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>
  <style type="text/css">
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}

@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

body {
  font: 11pt cambria, helvetica, arial, sans-serif;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 1em auto;
  max-width: 700px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: candara, helvetica, arial, sans-serif;
  font-size-adjust: 0.5;
}
.title { font-size: 150%; }
h1 { font-size: 130%; }
h2 { font-size: 120%; }
h3, h4 { font-size: 110%; }

table {
  margin-left: 0em;
}
table.header {
  width: 100%;
}

table.header td {
  background-color: inherit;
  color: black;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}

pre.text, pre.text2 {
  width: 90%;
}

dt {
  float: left; clear: left;
  margin: 0.5em 0.5em 0 0;
}
dt:first-child {
  margin-top: 0;
}
dd {
  margin: 0.5em 0 0 2em;
}
dd p, dd ul {
  margin-top: 0; margin-bottom: 0;
}
dd *+p {
  margin-top: 0.5em;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}
ul.toc a:first-child {
  display: inline-block;
  min-width: 1.2em;
}
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Reactive Certificate Authentication in HTTP/1.1"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 TLS 1.3 Client Authentication"/>
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Reactive Client Authentication in HTTP/2"/>
<link href="#rfc.section.1.4" rel="Chapter" title="1.4 Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 HTTP/2 Request Correlation in TLS 1.3"/>
<link href="#rfc.section.3" rel="Chapter" title="3 HTTP/2 Request Correlation in TLS 1.2"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The TLS application_context_id Hello Extension"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Permitting TLS Renegotiation in HTTP/2"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Indicating Stream Dependency on Certificate Authentication"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Indicating Support for Reactive Certificate Authentication"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 TLS application_context_id Extension"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 HTTP/2 SETTINGS_REACTIVE_AUTH Setting"/>
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 HTTP/2 WAITING_FOR_AUTH Frame"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="9 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Thomson, M. and M. Bishop" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-thomson-http2-client-certs-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-10-12" />
  <meta name="dct.abstract" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation." />
  <meta name="description" content="Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation." />

</head>

<body>
<a href="https://github.com/martinthomson/http2-client-certs"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">HTTP</td>
  <td class="right">M. Thomson</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Mozilla</td>
</tr>
<tr>
  <td class="left">Updates: 7450 (if approved)</td>
  <td class="right">M. Bishop</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">Microsoft</td>
</tr>
<tr>
  <td class="left">Expires: April 14, 2016</td>
  <td class="right">October 12, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Reactive Certificate-Based Client Authentication in HTTP/2<br />
  <span class="filename">draft-thomson-http2-client-certs-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>Some HTTP servers provide a subset of resources that require additional authentication to interact with.  HTTP/1.1 servers rely on TLS renegotiation that is triggered by a request to a protected resource.  HTTP/2 made this pattern impossible by forbidding the use of TLS renegotiation.</p>
<p>This document describes a how client authentication might be requested by a server as a result of receiving a request to a protected resource.  This document updates RFC 7540 to allow TLS renegotiation in limited circumstances.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 14, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Reactive Certificate Authentication in HTTP/1.1</a></li>
<li>1.2.   <a href="#rfc.section.1.2">TLS 1.3 Client Authentication</a></li>
<li>1.3.   <a href="#rfc.section.1.3">Reactive Client Authentication in HTTP/2</a></li>
<li>1.4.   <a href="#rfc.section.1.4">Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">HTTP/2 Request Correlation in TLS 1.3</a></li>
<li>3.   <a href="#rfc.section.3">HTTP/2 Request Correlation in TLS 1.2</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The TLS application_context_id Hello Extension</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Permitting TLS Renegotiation in HTTP/2</a></li>
</ul><li>4.   <a href="#rfc.section.4">Indicating Stream Dependency on Certificate Authentication</a></li>
<li>5.   <a href="#rfc.section.5">Indicating Support for Reactive Certificate Authentication</a></li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">TLS application_context_id Extension</a></li>
<li>7.2.   <a href="#rfc.section.7.2">HTTP/2 SETTINGS_REACTIVE_AUTH Setting</a></li>
<li>7.3.   <a href="#rfc.section.7.3">HTTP/2 WAITING_FOR_AUTH Frame</a></li>
</ul><li>8.   <a href="#rfc.section.8">Acknowledgements</a></li>
<li>9.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Many existing HTTP <a href="#RFC7230">[RFC7230]</a> servers have different authentication requirements for the different resources they serve.  Of the bountiful authentication options available for authenticating HTTP requests, client certificates present a unique challenge for resource-specific authentication requirements because of the interaction with the underlying TLS <a href="#I-D.ietf-tls-tls13">RFC5246</a> <cite title="NONE">[I-D.ietf-tls-tls13]</cite> layer.</p>
<p id="rfc.section.1.p.2">For servers that wish to use client certificates to authenticate users, they might request client authentication during the TLS handshake.  However, if not all users or resources need certificate-based authentication, a request for a certificate has the unfortunate consequence of triggering the client to seek a certificate.  Such a request can result in a poor experience, particular when sent to a client that does not expect the request.</p>
<p id="rfc.section.1.p.3">The TLS CertificateRequest can be used by servers to give clients hints about which certificate to offer.  Servers that rely on certificate-based authentication might request different certificates for different resources.  Such a server cannot use contextual information about the resource to construct an appropriate TLS CertificateRequest message during the initial handshake.</p>
<p id="rfc.section.1.p.4">Consequently, client certificates are requested at connection establishment time only in cases where all clients are expected or required to have a single certificate that is used for all resources.  Many other uses for client certificates are reactive, that is, certificates are requested in response to the client making a request.</p>
<p/>

<dl>
  <dt>CAVEAT:</dt>
  <dd style="margin-left: 8">As of 2015-10-02, TLS 1.3 does not include the client authentication features this draft relies on.  While these features have been agreed in the TLS working group, the exact design is still under revision.  The basic functionality shouldn&#8217;t change in a way that will affect this document, though some details such as field names are highly likely to change.</dd>
</dl>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#reactive-certificate-authentication-in-http11" id="reactive-certificate-authentication-in-http11">Reactive Certificate Authentication in HTTP/1.1</a></h1>
<p id="rfc.section.1.1.p.1">In HTTP/1.1, a server that relies on client authentication for a subset of users or resources does not request a certificate when the connection is established.  Instead, it only requests a client certificate when a request is made to a resource that requires a certificate.</p>
<p><a href="#ex-http11">Figure 1</a> shows the server initiating a TLS-layer renegotiation in response to receiving an HTTP/1.1 request to a protected resource.</p>
<div id="rfc.figure.1"/>
<div id="ex-http11"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt; *1
   &lt;---------------------- (TLS) HelloRequest -- *2
   -- (TLS) ClientHello -----------------------&gt;
   &lt;------------------ (TLS) ServerHello, ... --
   &lt;---------------- (TLS) CertificateRequest -- *3
   -- (TLS) ..., Certificate ------------------&gt; *4
   -- (TLS) Finished --------------------------&gt;
   &lt;-------------------------- (TLS) Finished --
   &lt;--------------------------- (HTTP) 200 OK -- *5
</pre>
<p class="figure">Figure 1: HTTP/1.1 Reactive Certificate Authentication with TLS 1.2</p>
<p id="rfc.section.1.1.p.3">In this example, the server receives a request for a protected resource (at *1 on <a href="#ex-http11">Figure 1</a>).  Upon performing an authorization check, the server determines that the request requires authentication using a client certificate and that no such certificate has been provided.</p>
<p id="rfc.section.1.1.p.4">The server initiates TLS renegotiation by sending a TLS HelloRequest (at *2).  The client then initiates a TLS handshake.  Note that some TLS messages are elided from the exchange for the sake of brevity.</p>
<p id="rfc.section.1.1.p.5">The critical messages for this example are the server requesting a certificate with a TLS CertificateRequest (*3); this request might use information about the request or resource.  The client then provides a certificate and proof of possession of the private key in Certificate and CertificateVerify messages (*4).</p>
<p id="rfc.section.1.1.p.6">When the handshake completes, the server performs any authorization checks a second time.  With the client certificate available, it then authorizes the request and provides a response (*5).</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#tls-13-client-authentication" id="tls-13-client-authentication">TLS 1.3 Client Authentication</a></h1>
<p id="rfc.section.1.2.p.1">TLS 1.3 <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> introduces a new client authentication mechanism that allows for clients to authenticate after the handshake has been completed.  For the purposes of authenticating an HTTP request, this is functionally equivalent to renegotiation.  <a href="#ex-tls13">Figure 2</a> shows the simpler exchange this enables.</p>
<div id="rfc.figure.2"/>
<div id="ex-tls13"/>
<pre>
Client                                      Server
   -- (HTTP) GET /protected -------------------&gt;
   &lt;---------------- (TLS) CertificateRequest --
   -- (TLS) Certificate -----------------------&gt;
   &lt;--------------------------- (HTTP) 200 OK --
</pre>
<p class="figure">Figure 2: HTTP/1.1 Reactive Certificate Authentication with TLS 1.3</p>
<p id="rfc.section.1.2.p.2">TLS 1.3 does not support renegotiation, instead supporting direct client authentication.  In contrast to the TLS 1.2 example, in TLS 1.3, a server can simply request a certificate.</p>
<h1 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a> <a href="#reactive-client-authentication-in-http2" id="reactive-client-authentication-in-http2">Reactive Client Authentication in HTTP/2</a></h1>
<p id="rfc.section.1.3.p.1">An important part of the HTTP/1.1 exchange is that the client is able to easily identify the request that caused the TLS renegotiation.  The client is able to assume that the next unanswered request on the connection is responsible.  The HTTP stack in the client is then able to direct the certificate request to the application or component that initiated that request.  This ensures that the application has the right contextual information for processing the request.</p>
<p id="rfc.section.1.3.p.2">In HTTP/2, a client can have multiple outstanding requests.  Without some sort of correlation information, a client is unable to identify which request caused the server to request a certificate.</p>
<p id="rfc.section.1.3.p.3">Thus, the minimum necessary mechanism to support reactive certificate authentication in HTTP/2 is an identifier that can be use to correlate an HTTP request with either a TLS renegotiation or CertificateRequest.</p>
<p><a href="#aci-13">Section 2</a> describes how the existing TLS 1.3 fields and a new HTTP/2 frame described in <a href="#frame">Section 4</a> can be used to correlate a request with a TLS CertificateRequest.  <a href="#aci-12">Section 3</a> describes how the same can be done in TLS 1.2 using TLS renegotiation and a new TLS <samp>application_context_id</samp> extension.  Finally, <a href="#setting">Section 5</a> describes how an HTTP/2 client can announce support for this feature so that a server might use these capabilities.</p>
<h1 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a> <a href="#terminology" id="terminology">Terminology</a></h1>
<p id="rfc.section.1.4.p.1">RFC 2119 <a href="#RFC2119">[RFC2119]</a> defines the terms &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;SHOULD&#8221; and &#8220;MAY&#8221;.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#aci-13" id="aci-13">HTTP/2 Request Correlation in TLS 1.3</a></h1>
<p id="rfc.section.2.p.1">An HTTP/2 request from a client that has signaled support for reactive certificate authentication (see <a href="#setting">Section 5</a>) might cause a server to request client authentication.  In TLS 1.3 a server does this by sending a new TLS 1.3 CertificateRequest.</p>
<p id="rfc.section.2.p.2">The server MUST first send a WAITING_FOR_AUTH frame (see <a href="#frame">Section 4</a>) on the stream which triggered the request for client credentials.  The certificate_request_id (name TBD) field of the TLS CertificateRequest is populated by the server with the same value in the WAITING_FOR_AUTH frame.  Subsequent WAITING_FOR_AUTH frames MAY be sent when the server is awaiting ongoing client authentication before responding.  This allows a client to correlate the TLS CertificateRequest with one or more outstanding requests.</p>
<p id="rfc.section.2.p.3">A server MAY send multiple TLS CertificateRequest messages.  If a server requires that a client provide multiple certificates before authorizing a single request, it MUST await a response to the first TLS CertificateRequest message before sending another TLS CertificateRequest for the same stream.  CertificateRequest messages for other streams MAY be sent without waiting.  The server MUST precede each new CertificateRequest with a new WAITING_FOR_AUTH frame referencing it.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#aci-12" id="aci-12">HTTP/2 Request Correlation in TLS 1.2</a></h1>
<p id="rfc.section.3.p.1">An HTTP/2 server that uses TLS 1.2 initiates client authentication by sending a an HTTP/2 WAITING_FOR_AUTH frame containing a random value, followed by a TLS HelloRequest.  This triggers a TLS renegotiation.</p>
<p id="rfc.section.3.p.2">An HTTP/2 client that receives a TLS HelloRequest message MUST initiate a TLS handshake, including an empty <samp>application_context_id</samp> extension.  If the client has not indicated support for renegotiation (see <a href="#setting">Section 5</a>), the client MUST send a fatal TLS <samp>no_renegotiation</samp> alert.</p>
<p id="rfc.section.3.p.3">The server populates the <samp>application_context_id</samp> extension with the same value previously used in the WAITING_FOR_AUTH frame.</p>
<p id="rfc.section.3.p.4">Absence of an <samp>application_context_id</samp> extension or an empty value from the server MUST be treated as a fatal error; endpoints MAY send a fatal TLS <samp>no_renegotiation</samp> alert.</p>
<p id="rfc.section.3.p.5">As with the TLS 1.3 solution, a server MAY request multiple client certificates, either for different requests or for the same request.  If multiple requests are waiting for authentication and require different certificates, the server SHOULD immediately send the WAITING_FOR_AUTH frames with unique values.  Only one TLS renegotiation can be in progress at a time, though a new HelloRequest can be emitted once the renegotiation has completed.</p>
<p id="rfc.section.3.p.6">A server MAY treat all certificates presented in the same connection as cumulative, remembering multiple certificates as they are presented.  Note that the authentication information collected from the client will need to be checked after each TLS renegotiation completes, since most TLS stacks only report the presence of the client certificate presented during the last TLS handshake.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#extension" id="extension">The TLS application_context_id Hello Extension</a></h1>
<p id="rfc.section.3.1.p.1">The <samp>application_context_id</samp> TLS Hello Extension is used to carry an identifier from an application context in the TLS handshake.  This is used to identify the application context that caused the TLS handshake to be initiated.  The semantics of the field depend on application protocol, and could further depend on application protocol state.</p>
<p id="rfc.section.3.1.p.2">Either client or server can populate this field.  A client can provide an empty value to indicate that it does not know the application context, but would like the server to provide a value.  A server can provide an empty value in response to a non-empty value only.</p>
<p id="rfc.section.3.1.p.3">In HTTP/2 clients always provide an empty <samp>application_context_id</samp> value, and servers always provide a value that will appear in a subsequent WAITING_FOR_AUTH frame.</p>
<div id="rfc.figure.3"/>
<div id="acid-extension"/>
<pre>
enum {
    ...
    application_context_id(EXTENSION-TBD),
    (65535)
} ExtensionType;

struct {
    opaque id&lt;0..255&gt;;
} ApplicationContextId;
</pre>
<p class="figure">Figure 3: The application_context_id Extension Format</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#update" id="update">Permitting TLS Renegotiation in HTTP/2</a></h1>
<p id="rfc.section.3.2.p.1">The prohibition from Section 9.2.1 of <a href="#RFC7540">[RFC7540]</a> against TLS renegotiation is removed, provided that the requirements of this section are adhered to.</p>
<p id="rfc.section.3.2.p.2">TLS renegotiation MUST NOT be used to circumvent the other restrictions on TLS use from Section 9.2 of <a href="#RFC7540">[RFC7540]</a>.  Furthermore, TLS renegotiation MUST negotiate the same ALPN [RFC7301] identifier (that is, &#8220;h2&#8221;).  An endpoint MAY treat failure to comply with these requirements as a connection error (Section 5.4.1 of <a href="#RFC7540">[RFC7540]</a>) of type INADEQUATE_SECURITY.</p>
<p/>

<dl>
  <dt>Note:</dt>
  <dd style="margin-left: 8">A client need not offer cipher suites that might otherwise be offered for compatibility reasons when renegotiating.  In particular, cipher suites on the black list from Appendix A of <a href="#RFC7540">[RFC7540]</a> can be removed from the handshake.</dd>
</dl>
<p id="rfc.section.3.2.p.4">In addition to the requirements from <a href="#RFC7540">[RFC7540]</a>, endpoints that renegotiate MUST implement the TLS extended master secret extension <a href="#RFC7627">[RFC7627]</a> and the TLS renegotiation indication extension <a href="#RFC5746">[RFC5746]</a>.  These extensions MUST be negotiated and used to prevent serious attacks on TLS renegotiation.  If an endpoint receives a TLS ClientHello or ServerHello that does not include these extensions, it MUST respond with a fatal TLS <samp>no_renegotiation</samp> alert.</p>
<p id="rfc.section.3.2.p.5">The TLS renegotiation handshake MUST include the <samp>application_context_id</samp> extension when used with HTTP/2.</p>
<p id="rfc.section.3.2.p.6">A server MUST present the same certificate during TLS renegotiation it used during the initial handshake.  Clients MUST verify that the server certificate does not change.  Clients MUST verify that the server certificate has not changed; a different certificate MUST be treated as a fatal error and MAY cause a fatal <samp>handshake_failure</samp> alert to be sent.</p>
<p id="rfc.section.3.2.p.7">Once the HTTP/2 connection preface has been received from a peer, an endpoint SHOULD treat the receipt of a TLS ClientHello or ServerHello without an <samp>application_context_id</samp> extension as a fatal error and SHOULD send a fatal TLS <samp>no_renegotiation</samp> alert.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#frame" id="frame">Indicating Stream Dependency on Certificate Authentication</a></h1>
<p id="rfc.section.4.p.1">Servers which employ reactive certificate authentication can require that authentication on multiple resources.  Because many requests could be awaiting responses to the same CertificateRequest, it is insufficient to use the stream ID as the <samp>certificate_request_id</samp> or <samp>application_context_id</samp>.</p>
<p id="rfc.section.4.p.2">The frame is structured as follows:</p>
<div id="rfc.figure.4"/>
<div id="wfa-frame"/>
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |X|                       Request ID (31)                       |
 +-+-------------------------------------------------------------+
</pre>
<p class="figure">Figure 4: The WAITING_FOR_AUTH frame</p>
<p id="rfc.section.4.p.3">The WAITING_FOR_AUTH frame is sent by servers to indicate that processing of a request is blocked pending authentication outside of the HTTP channel. The frame includes a Request ID which can be used to correlate the stream with challenges for authentication received at other layers, such as TLS.</p>
<p id="rfc.section.4.p.4">The WAITING_FOR_AUTH frame MUST NOT be sent by clients.  A WAITING_FOR_AUTH frame received by a server SHOULD be rejected with a stream error of type PROTOCOL_ERROR.</p>
<p id="rfc.section.4.p.5">The server MUST NOT send a WAITING_FOR_AUTH frame on stream zero, a server-initiated stream or a stream that does not have an outstanding request.  In other words, a server can only send in the &#8220;open&#8221; or &#8220;half-closed (remote)&#8221; stream states.  A server SHOULD NOT send the frame until after having initiated the out-of-band authentication challenge.</p>
<p id="rfc.section.4.p.6">A client that receives a WAITING_FOR_AUTH frame on a stream which is not in a valid state (&#8220;open&#8221; or &#8220;half-closed (local)&#8221; for clients) SHOULD treat this as a connection error of type PROTOCOL_ERROR.  A client that receives a WAITING_FOR_AUTH frame which does not match an outstanding authentication request MAY treat this as a stream error if no challenge is received within a few seconds.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#setting" id="setting">Indicating Support for Reactive Certificate Authentication</a></h1>
<p id="rfc.section.5.p.1">Clients that support reactive certificate authentication indicate this using the HTTP/2 <samp>SETTINGS_REACTIVE_AUTH</samp> (0xSETTING-TBD) setting.</p>
<p id="rfc.section.5.p.2">The initial value for the <samp>SETTINGS_REACTIVE_AUTH</samp> setting is 0, indicating that the client does not support reactive client authentication.  A client sets the <samp>SETTINGS_REACTIVE_AUTH</samp> setting to a value of 1 to indicate support for reactive certificate authentication as defined in this document.  Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1 of <a href="#RFC7540">[RFC7540]</a>) of type PROTOCOL_ERROR.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">The TLS extended master secret extension <a href="#RFC7627">[RFC7627]</a> and the TLS renegotiation indication extension <a href="#RFC5746">[RFC5746]</a> MUST be used to mitigate several known attacks on TLS renegotiation.</p>
<p id="rfc.section.6.p.2">Adding correlation between requests and TLS-layer authentication addresses the primary functional concerns with mid-session client authentication.  However, implementations need to be aware of the potential for confusion about the state of a connection.</p>
<p id="rfc.section.6.p.3">The presence or absence of a validated client certificate can change during the processing of a request, potentially multiple times.  A server that uses reactive certificate authentication needs to be prepared to reevaluate the authorization state of a request as the set of certificates changes.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">The TLS <samp>application_context_id</samp> extension is registered in <a href="#iana-extension">Section 7.1</a>.  The HTTP/2 <samp>SETTINGS_REACTIVE_AUTH</samp> setting is registered in <a href="#iana-setting">Section 7.2</a>.  The HTTP/2 <samp>WAITING_FOR_AUTH</samp> frame type is registered in <a href="#iana-frame">Section 7.3</a>.</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#iana-extension" id="iana-extension">TLS application_context_id Extension</a></h1>
<p id="rfc.section.7.1.p.1">The <samp>application_context_id</samp> TLS extension is registered in the &#8220;ExtensionType Values&#8221; registry established by <a href="#RFC5246">[RFC5246]</a>.</p>
<p/>

<dl>
  <dt>Value:</dt>
  <dd style="margin-left: 8">EXTENSION-TBD</dd>
  <dt>Extension name:</dt>
  <dd style="margin-left: 8">application_context_id</dd>
  <dt>Reference:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#iana-setting" id="iana-setting">HTTP/2 SETTINGS_REACTIVE_AUTH Setting</a></h1>
<p id="rfc.section.7.2.p.1">The SETTINGS_REACTIVE_AUTH setting is registered in the &#8220;HTTP/2 Settings&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">SETTINGS_REACTIVE_AUTH</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xSETTING-TBD</dd>
  <dt>Initial Value:</dt>
  <dd style="margin-left: 8">0</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.7.3"><a href="#rfc.section.7.3">7.3.</a> <a href="#iana-frame" id="iana-frame">HTTP/2 WAITING_FOR_AUTH Frame</a></h1>
<p id="rfc.section.7.3.p.1">The WAITING_FOR_AUTH frame type is registered in the &#8220;HTTP/2 Frame Types&#8221; registry established in <a href="#RFC7540">[RFC7540]</a>.</p>
<p/>

<dl>
  <dt>Name:</dt>
  <dd style="margin-left: 8">WAITING_FOR_AUTH</dd>
  <dt>Code:</dt>
  <dd style="margin-left: 8">0xSETTING-TBD</dd>
  <dt>Initial Value:</dt>
  <dd style="margin-left: 8">0</dd>
  <dt>Specification:</dt>
  <dd style="margin-left: 8">This document.</dd>
</dl>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#ack" id="ack">Acknowledgements</a></h1>
<p id="rfc.section.8.p.1">Eric Rescorla pointed out several failings in an earlier revision.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-08">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-08, August 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5746">[RFC5746]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, <a>Ray, M.</a>, <a>Dispensa, S.</a> and <a>N. Oskov</a>, "<a href="http://tools.ietf.org/html/rfc5746">Transport Layer Security (TLS) Renegotiation Indication Extension</a>", RFC 5746, DOI 10.17487/RFC5746, February 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7230">[RFC7230]</b>
      </td>
      <td class="top"><a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="http://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7627">[RFC7627]</b>
      </td>
      <td class="top"><a>Bhargavan, K.</a>, <a>Delignat-Lavaud, A.</a>, <a>Pironti, A.</a>, <a>Langley, A.</a> and <a>M. Ray</a>, "<a href="http://tools.ietf.org/html/rfc7627">Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension</a>", RFC 7627, DOI 10.17487/RFC7627, September 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Martin Thomson</span> 
	  <span class="n hidden">
		<span class="family-name">Thomson</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:martin.thomson@gmail.com">martin.thomson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Mike Bishop</span> 
	  <span class="n hidden">
		<span class="family-name">Bishop</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:michael.bishop@microsoft.com">michael.bishop@microsoft.com</a></span>

  </address>
</div>

</body>
</html>
